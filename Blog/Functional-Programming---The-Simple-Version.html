<!DOCTYPE html>
<html lang="en"><head><title>Functional Programming - The Simple Version</title><meta charset="utf-8"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Schibsted Grotesk:wght@400;700&amp;family=Source Sans Pro:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="Functional Programming - The Simple Version"/><meta property="og:description" content="I think functional programming (FP) has become a necessary skill to have for any software developer or programmer in general. Considering the tools used in industry today, like React.js, Elm, and all the popular functional languages, you don’t want to miss out on all the awesomeness."/><meta property="og:image" content="https://tabaza.dev/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../static/icon.png"/><meta name="description" content="I think functional programming (FP) has become a necessary skill to have for any software developer or programmer in general. Considering the tools used in industry today, like React.js, Elm, and all the popular functional languages, you don’t want to miss out on all the awesomeness."/><meta name="generator" content="Quartz"/><link href="../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><script src="../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch("../static/contentIndex.json").then(data => data.json())</script></head><body data-slug="Blog/Functional-Programming---The-Simple-Version"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title"><a href="..">Mohammad Tabaza</a></h1><div class="spacer mobile-only"></div><div class="search"><div id="search-icon"><p>Search</p><div></div><svg tabindex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="search-layout" data-preview="true"></div></div></div></div><div class="darkmode"><input class="toggle" id="darkmode-toggle" type="checkbox" tabindex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35" xml:space="preserve"><title>Dark mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabindex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background:new 0 0 100 100" xml:space="preserve"><title>Light mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="explorer desktop-only"><button type="button" id="explorer" data-behavior="collapse" data-collapsed="collapsed" data-savestate="true" data-tree="[{&quot;path&quot;:&quot;Bits&quot;,&quot;collapsed&quot;:true},{&quot;path&quot;:&quot;Blog&quot;,&quot;collapsed&quot;:true}]"><h1>Explorer</h1><svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="explorer-content"><ul class="overflow" id="explorer-ul"><li><div class="folder-outer open"><ul style="padding-left:0;" class="content" data-folderul><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Bits"><button class="folder-button"><span class="folder-title">Bits</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Bits"><li><a href="../Bits/I-Hope-Swift-Wins" data-for="Bits/I-Hope-Swift-Wins">I Hope Swift Wins</a></li><li><a href="../Bits/Atlas-Is-the-Best-DB-Migration-Tool" data-for="Bits/Atlas-Is-the-Best-DB-Migration-Tool">Atlas Is the Best DB Migration Tool</a></li><li><a href="../Bits/Do-Not-Re-Invent-the-Wheel" data-for="Bits/Do-Not-Re-Invent-the-Wheel">Do Not Re-Invent the Wheel</a></li><li><a href="../Bits/Mindless-Learning" data-for="Bits/Mindless-Learning">Mindless Learning</a></li><li><a href="../Bits/How-two-WhatsApp-Chat-Bots-had-a-Fight" data-for="Bits/How-two-WhatsApp-Chat-Bots-had-a-Fight">How two WhatsApp Chat Bots had a Fight</a></li></ul></div></li><li><div class="folder-container"><svg xmlns="http://www.w3.org/2000/svg" width="12" height="12" viewBox="5 8 14 8" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="folder-icon"><polyline points="6 9 12 15 18 9"></polyline></svg><div data-folderpath="Blog"><button class="folder-button"><span class="folder-title">Blog</span></button></div></div><div class="folder-outer "><ul style="padding-left:1.4rem;" class="content" data-folderul="Blog"><li><a href="../Blog/DevOps---The-Simple-Version" data-for="Blog/DevOps---The-Simple-Version">DevOps - The Simple Version</a></li><li><a href="../Blog/Functional-Programming---The-Simple-Version" data-for="Blog/Functional-Programming---The-Simple-Version">Functional Programming - The Simple Version</a></li><li><a href="../Blog/A-Guide-to-Scala-3" data-for="Blog/A-Guide-to-Scala-3">A Guide to Scala 3</a></li><li><a href="../Blog/The-Scala-Collections-Library" data-for="Blog/The-Scala-Collections-Library">The Scala Collections Library</a></li><li><a href="../Blog/Parsing-The-World-with-Rust-and-POM" data-for="Blog/Parsing-The-World-with-Rust-and-POM">Parsing The World with Rust and POM</a></li><li><a href="../Blog/Machine-Learning---From-Zero-to-Slightly-Less-Confused" data-for="Blog/Machine-Learning---From-Zero-to-Slightly-Less-Confused">Machine Learning - From Zero to Slightly Less Confused</a></li><li><a href="../Blog/RxJS-From-Scratch" data-for="Blog/RxJS-From-Scratch">RxJS From Scratch</a></li><li><a href="../Blog/FeathersJS-For-The-Beginner---Hello-World!" data-for="Blog/FeathersJS-For-The-Beginner---Hello-World!">FeathersJS For The Beginner - Hello World!</a></li><li><a href="../Blog/FeathersJS-For-The-Beginner---Basic-concepts" data-for="Blog/FeathersJS-For-The-Beginner---Basic-concepts">FeathersJS For The Beginner - Basic concepts</a></li></ul></div></li><li><div class="folder-outer "><ul style="padding-left:0;" class="content" data-folderul></ul></div></li></ul></div></li><li id="explorer-end"></li></ul></div></div></div><div class="center"><div class="page-header"><div class="popover-hint"><nav class="breadcrumb-container" aria-label="breadcrumbs"><div class="breadcrumb-element"><a href="../">Home</a><p> ❯ </p></div><div class="breadcrumb-element"><a href="../Blog/">Blog</a><p> ❯ </p></div><div class="breadcrumb-element"><a href>Functional Programming - The Simple Version</a></div></nav><h1 class="article-title">Functional Programming - The Simple Version</h1><p show-comma="true" class="content-meta"><span>Feb 08, 2020</span><span>27 min read</span></p></div></div><article class="popover-hint"><p><img src="https://cdn-images-1.medium.com/max/600/1*CQIMmcApInuuBxNSY8xCCw.jpeg" alt/></p>
<p>I think functional programming (FP) has become a necessary skill to have for any software developer or programmer in general. Considering the tools used in industry today, like React.js, <a href="https://elm-lang.org/" class="external">Elm<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, and all the popular functional languages, you don’t want to miss out on all the awesomeness. Despite the fact that you need a certain level of understanding of functional programming in order to be proficient in use of these tools, understanding of the general concepts of FP can make you a much better software developer in general. Plus, a lot of frameworks and programming languages that aren’t considered functional actually have functional features. Python, JavaScript, Java, C#, Dart, and many other languages have quality of life functional features that can save you a lot of time and headache if you know how to use them properly.</p>
<p>If you look carefully at these tools, you notice a lot of underlying concepts that are common to all of them. Having a solid understanding of the fundamentals on which these tools were built can carry you much of the way towards mastering them, and certainly makes your life easier when learning to use new tools (and judging them.)</p>
<p>In this article, I attempt to explain the basics of FP using <a href="https://www.haskell.org/" class="external">Haskell<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>. Don’t worry if that sounds scary, it’s really simple stuff.</p>
<h3 id="functions">Functions!<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#functions" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>If you squint hard at any computer program, you notice that it’s essentially the following:</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*pPe50MAjBeF-D07Px2KUjg.jpeg" alt/></p>
<p>It’s a process that you feed data, and outputs something. The input can be anything from user clicks, to command line arguments, and the output can be a file, or search results.</p>
<p>There’s a really simple way to express this notion of transforming input to output: <em>mathematical functions</em>. If you already have a good understanding of functions, I can understand why you might be skeptical of the idea that any program can be modeled as a mathematical function. You’re right, a function can’t be used to model writing a file to disk. However, functions <strong>are</strong> the simplest way to model data transformations, which make up most of our programs..</p>
<p>You may have learned about functions in programming. When I’m talking about functions, I do not mean “customizable and reusable pieces of code.” What I mean is way simpler than to print something to the screen, or to change the value of some variable outside of it. If you’re not familiar with mathematical functions, let me explain.</p>
<p>A <a href="https://en.wikipedia.org/wiki/Function_%28mathematics%29" class="external">function in mathematics<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> is a relation between two sets <em>A</em> and <em>B</em>, such that every element in <em>A</em> is associated with one <strong>and only one</strong> element of <em>B</em>. Sounds complicated? This might help:</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*-HTPfpmUS3vxpARVcGJptw.jpeg" alt/></p>
<p>In essence, a set is a collection of unique elements. In this example, we have two sets: Names (with a capital N,) and Lengths (with a capital L.) These two sets are related in the sense that every name has a length (the number of characters in it.) Since every name is associated with only one length, we can call this relation a mathematical function. Let’s call this function <code>length</code>.</p>
<p>Functions can be thought of as <em>mappings</em> between elements of sets. In <code>length</code>, the element “John” is mapped to 4. We note this mapping as <em>length(</em>“John”<em>)</em>=4, which in plain English translates to: length of “John” equals 4. We can also say that <em>applying</em> <code>length</code> to “John” yields 4.</p>
<p>A value passed to a function as input is called an <em>argument</em> of the function. When a function is applied to an argument, the result is called the <em>image</em> of that argument, and the argument itself is called the <em>preimage</em> . In <code>length</code>, the image of “Jane” is 4.</p>
<p>Notice how the mapping has a direction: it goes from Names to Lengths. More generally, we call the “original” set the <em>domain</em> of the function, and the set to which the elements of the domain are mapped the <em>co-domain</em>. For <code>length</code>, the domain is the set Names, and the co-domain is the set Lengths.</p>
<p>You can type the expression <code>length(&quot;John&quot;)</code> into this <a href="https://repl.it/languages/haskell" class="external">Haskell REPL<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> to the right and hit Enter to get the result. A REPL is just a program that reads, evaluates, and prints the result of expressions you give it. Feel free to try running any code you see in this article.</p>
<p>Any function can be expressed as a set of pairs. Each pair in this set consists of a value from the domain, and its corresponding image in the co-domain. Our little <code>length</code> function can be expressed as:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jane&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">), (</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jackson&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]</span></span></code></pre></figure>
<p>where all the elements between the brackets (<code>[]</code>) form a set. In programming (inconveniently,) it is not necessarily the case that all the pairs that form a function are known before executing it. Imagine a function from the infinite set of integers (ℤ) to the infinite set of real numbers (ℝ.) How can we possibly fit all the pairs that form this function in the finite memory of a computer? Stay tuned.</p>
<hr/>
<p>I guess it’s appropriate now that I define functional programming. FP is using mathematical functions as the primary building block of programs. In other <a href="https://en.wikipedia.org/wiki/Programming_paradigm" class="external">programming paradigms<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>, the primary building block would be instructions, or objects. Using functions instead gives you some superpowers that are beyond the scope of this article, but they’re very simple, which is a huge plus.</p>
<h4 id="equations">Equations<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#equations" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Earlier I implied that in programming, we normally don’t know all the pairs of preimages and images that form a function. Most of the time, we can’t even write these pairs down because there are so many (possibly <em>infinitely</em> many.) Consider a function that maps an integer to its increment (the number + 1.) This function is impossible to write out as a set of pairs because the integers never end.</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*afcY2GRd5AECpMAd8VmW8A.jpeg" alt/></p>
<p>In such cases, we can express the function as an <em>equation</em>. A formula that the <em>computer</em> can use to <em>compute</em> the image of a given argument. In the case of our increment function, writing the equation isn’t very difficult:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment(x) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></figure>
<p>This equation is read: “the increment of <em>x</em> is equal to <em>x</em> + 1.” Isn’t it wonderful! Instead of writing out the mapping with <em>concrete</em> arguments in this form:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">...</span></span></code></pre></figure>
<p>We can <em>generalize</em> the formula to work with any given integer by making the argument’s value unknown in the equation, making it a <em>parameter</em>. The image of a particular value can be computed by applying the function:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></figure>
<p>This expression will yield <code>61</code> (the image of <code>60</code>.)</p>
<p>In Haskell, you actually don’t need parentheses in function definitions and applications. You can use spaces instead:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span></span></code></pre></figure>
<p>We can call function definitions <em>equations</em> in Haskell because the two sides are literally equal. You can take out any application of a function and put the evaluated right-hand side of the function equation in its place, and you would get exactly the same result. The same can be said for any Haskell expression. Think of it as being able to take out <code>250 * 2</code> and placing <code>500</code> instead of it. This property is known as <em>referential transparency</em>, and it just makes programs much easier to think about_._</p>
<h3 id="function-types">Function Types<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#function-types" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Remember what I said about mapping having a direction? Let’s take a closer look at our <code>increment</code> function. It is a function that maps the elements of the set of integers (ℤ) to the set of integers + 1 (also ℤ.) In mathematics, this direction is noted as ℤ ↦ ℤ. In Haskell, we think a lot about the <em>types</em> (basically sets)of data that we operate on. There are many predefined sets already built into the language, such as <code>Int</code> for integers, <code>Float</code> for floating-point numbers, <code>Bool</code> for <code>True</code> and <code>False</code>, and <code>String</code> for text. But functions have types of their own. A function going from integers to integers has the type <code>Int -> Int</code>.</p>
<p>When defining a function, it is almost never necessary to explicitly specify its type. The Haskell compiler can figure the type of the function on its own by looking at how the function’s parameters are being used. Adding type annotations makes it easier for you to just look at the function’s name and type (its <em>signature</em>) and immediately have a good idea of what it does.</p>
<p>The definition of <code>increment</code> with explicit type annotations is as follows:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">increment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; increment x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span></code></pre></figure>
<p>Now you can read this definition as: “<code>increment</code> <em>is a</em> function from <code>Int to Int</code>; the increment of an integer <em>x</em> equals <em>x</em> + 1.”</p>
<p>When writing Haskell code in a file (not in the REPL,) you can write the type annotation on one line, and the actual function definition on the next line. This makes it possible to omit the semicolon (<code>;</code>.)</p>
<p>Looking at our definition of <code>increment</code> with the eyes of a lazy programmer, I can see a small problem: it can only be used to increment integers. Wouldn’t it be great if the function could be applied to arguments of any numeric type? It would make sense for us to use the same function to increment floating-point numbers too, right? Coming soon.</p>
<h4 id="functions-of-multiple-parameters">Functions of Multiple Parameters<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#functions-of-multiple-parameters" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h4>
<p>Let’s say we want to define a function <em>f</em> that takes two integer parameters: <em>x</em> and <em>y</em>. The function squares <em>x</em> and adds it to <em>y</em>. This is how it would look in Haskell:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f x y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span></span></code></pre></figure>
<p>Simple enough. Now you can apply <code>f</code> to two space-separated arguments:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span></code></pre></figure>
<p>which yields <code>7</code>. Great! Now on to the weird part.</p>
<p>If we were to redefine <code>f</code> with type annotations, it would look like this:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; f x y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y</span></span></code></pre></figure>
<p>That’s strange… Look at the type of <code>f</code>… It’s <code>Int -> Int -> Int</code>! Why is that? Shouldn’t it be <code>(Int, Int) -> Int</code> since it takes a pair of integers and maps them to a single integer? And what does it mean to have two arrows in a function’s type anyway?</p>
<p>This weirdness is a consequence of a concept called <em>currying</em>, which I’ll explain when it becomes useful.</p>
<hr/>
<p>Let’s take a break from types for now. In order for the rest of the concepts I’d like to explain to make sense and feel useful, I feel it is appropriate to take a look at a very important data structure first: the list.</p>
<h3 id="lists">Lists<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#lists" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>When you have a number of related data points that you would like to process together, it’s a good idea to store them in some sort of container that preserves their structure, and gives you some tools to help with your processing task. <em>Lists</em> are great data structures that do just that. They can be used to store data in an ordered manner, in the sense that the first element in the list comes before the second element, and the second comes before the third, and so on. Lists also let you easily walk through all the elements within them, transform them, filter them, and aggregate them.</p>
<p>Let’s define a list of the integers from 1 to 5 and name it <code>oneToFive</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">oneToFive</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]; oneToFive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></figure>
<p>You’ll notice that the type of <code>oneToFive</code> is <code>[Int]</code> (read “list of <code>Int</code>.”) We can construct lists by using square brackets (<code>[]</code>) to surround the comma-separated elements of the list. This is awesome! Let’s see what we can do with this list.</p>
<p>In Haskell, there are lots of predefined functions that operate on lists. One of these functions is <code>head</code>, which maps a list to its first element. For instance:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head oneToFive</span></span></code></pre></figure>
<p>would yield <code>1</code> (the first element of <code>[1,2,3,4,5]</code>.) Another function is <code>tail</code>, which maps a list to its self, but without the head:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">tail oneToFive</span></span></code></pre></figure>
<p>will yield <code>[2,3,4,5]</code>(<code>oneToFive</code> without <code>1</code>, the first element.) A list can be pictured as a snake, even though this is not a perfect analogy — snakes can’t regrow their heads:</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*qAeNtgL8H-oZImhxhCGnKQ.jpeg" alt/></p>
<p>Take the list’s head, and you’re left with its tail. A list’s tail is a list itself, so it has a head and a tail. Take the list’s tail’s head, and you have the second element (2.) Take the list’s tail’s tail’s tail’s tail’s head, and you’ll get 5:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">head(tail(tail(tail(tail(oneToFive)))))</span></span></code></pre></figure>
<p>How fun. What about the head of an empty list? Well, it doesn’t exist, so you can’t get it. The same goes for the tail of an empty list. Now, let us think for a moment about the tail of a list with one element. That’s tricky, but let’s reason about it this way:</p>
<p>If we have a list of five elements, then its tail should have 4 elements (5 minus the head.) So we can say that the length of the tail is the length of the whole list minus one. But it doesn’t make sense for a list to have a length less than 0 (being empty,) so the <em>base case</em>, or the most basic case for a list, is to be empty. So it makes sense for the smallest possible tail to be the empty list.</p>
<p>Other than using square brackets to construct lists, you can use the colon operator (<code>:</code>, a.k.a. the construction operator) to stick a head to a tail, therefore constructing a new list. For example, <code>oneToFive</code> can be defined as:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">oneToFive </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span></span></code></pre></figure>
<p>The expression is evaluated from right to left. We’re sticking <code>5</code> to <code>[]</code>, <code>4</code> to <code>[5]</code>, <code>3</code> to <code>[4,5]</code>, <code>2</code> to <code>[3,4,5]</code>, and <code>1</code> to <code>[2,3,4,5]</code>, thus getting <code>[1,2,3,4,5]</code>. Using this notation, it’s clear how the smallest possible tail of any list is the empty list (<code>[]</code>.) Without it, you wouldn’t be able to construct any list, because you wouldn’t be able to “end the cycle.” This brings us to a very important concept in functional programming: <em>recursion</em>.</p>
<h3 id="recursion">Recursion<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#recursion" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>A list can either be empty (<code>[]</code>,) or it can consist of an element <em>x</em> stuck to the beginning of a list (<code>x : aList</code>.) Do you notice anything weird about this definition of a list? We’re defining a list in terms of its self. It makes complete sense when you think about it. There are only two possible ways a list can exist: either as the empty list, or as a construction of a head and a tail list. The key here is that in a construction of a head and tail, the tail can be <em>any</em> list, either empty, or a construction of its own.</p>
<p>Let’s try to define a function that maps a list to the count of its elements. Let’s call it <code>count</code>.</p>
<p><img src="https://cdn-images-1.medium.com/max/600/1*pYhQZX4ExxDBWBkPhV0Y0Q.jpeg" alt/></p>
<p>This function should have one parameter: the list of elements we want to count. A list can either be empty, or a construction of at least one element (a head,) and a tail. These are the only two cases we have to deal with since the function only has one parameter, which is a list.</p>
<p>The first case is that of an empty list. Easy, an empty list has zero elements:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span></code></pre></figure>
<p>The second case is that of a construction. Hmm… A construction consists of a head (1 element,) and a tail (a list of unknown number of elements.) Ok, so the count of the elements in a construction is 1 + the count of the elements of the tail. Wait… Let’s write that down:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count(t)</span></span></code></pre></figure>
<p>where <code>h</code> is the head, and <code>t</code> is the tail. Together with the empty list case, the whole definition would be:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; count (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count(t)</span></span></code></pre></figure>
<p>Now that’s just magical. If what’s going on is not obvious, maybe this will help:</p>
<p>Earlier I explained how functions are equations. We can use this fact to understand how <code>count</code> works by applying it to some list (e.g. <code>oneToFive</code>,) and walking through the evaluation of the result one step at a time.</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">])))  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count([</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]))))  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> count(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">))))))  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)))))  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">count [</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 5</span></span></code></pre></figure>
<p>Again, notice how the evaluation would never have ended successfully without a base case (<code>count []</code>.)</p>
<p>In general, recursion is defining something in terms of its self. Data structures can be recursive; functions can be recursive; relations in general can be recursive. You’ll find that thinking recursively can make things a lot simpler sometimes.</p>
<p>You may have learned about loops in programming (e.g. <code>for</code> and <code>while</code> loops,) and you may be wondering why you would ever use recursion. Well, one reason is that Haskell and some other functional languages don’t have any looping constructs built into them. Another reason is that using recursion lets you use the equational reasoning we applied earlier when evaluating <code>count(oneToFive)</code> in all sorts of situations, saving you some brain power. Most importantly, though, I think recursion makes it easy to describe things clearly and concisely, which results in more understandable code.</p>
<h3 id="higher-order-functions">Higher-Order Functions<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#higher-order-functions" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Yet another scary term.</p>
<p>Let’s imagine a scenario where you have a list of integers, and you want to increment each of them. You define a function <code>incrementAll</code> that does just that:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">incrementAll </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; incrementAll (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> incrementAll t</span></span></code></pre></figure>
<p>Easy. To increment all the elements of an empty list, you do nothing with it. To increment all the elements of a construction, you increment its head, and stick it to all the incremented elements of the tail. Great. You later require a function to decrement all the integers in a list, so you define <code>decrementAll</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">decrementAll </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; decrementAll (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> decrementAll t</span></span></code></pre></figure>
<p>Later, you require another function to multiply the integers by two, so you define <code>doubleAll</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">doubleAll </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; doubleAll (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> doubleAll t</span></span></code></pre></figure>
<p>… There’s a problem here. We’re duplicating a lot of code, which quickly becomes boring. If you look at these three functions, you notice they’re essentially the same function, but they map the elements of the list differently. All three walk through the list recursively, and transform its elements using some function (e.g. <code>increment</code>.) How do we solve this problem?</p>
<p>Remember what I said about functions having types of their own? Functions can be divided into sets. There’s the set of functions from integers to integers (<code>Int -> Int</code>,) the set of functions from lists of integers to integers (<code>[Int] -> Int</code>,) and so on. We can think about a function as we would an integer; we can pass an integer as an argument to a function, right? Why not do the same with functions?</p>
<p>Let’s define a function <code>transform</code> that walks through a list, and transforms each element using a function <code>f</code> that we pass as an argument:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transform f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> []</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; transform f (h </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> t) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> f(h) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> transform f t</span></span></code></pre></figure>
<p>Looks awfully similar to the previous functions, but with the extra parameter <code>f</code>. What we’re doing here is that we’re leaving the function used to transform the elements up to the user of <code>transform</code>. All we do in <code>transform</code> is traverse a list, and apply a given function <code>f</code> to its elements. Let’s try using it with <code>increment</code> and <code>oneToFive</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transform increment oneToFive</span></span></code></pre></figure>
<p>yields <code>[2,3,4,5,6]</code>. Awesome! Note that <code>increment</code> and <code>oneToFive</code> are both arguments of <code>transform</code>. We are not applying <code>increment</code> to <code>oneToFive</code>. Now let’s try <code>transform</code> with <code>decrement</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">decrement x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">transform decrement oneToFive</span></span></code></pre></figure>
<p>yields <code>[0,1,2,3,4]</code>. It works! We can do the same with <code>doouble</code>, but you get the point. <code>transform</code> can be used with any function as long as its type is compatible with the type of the elements of the list.</p>
<p>A higher-order function is simply a function that takes a function as an argument. So <code>transform</code> is a higher-order function. Many of these functions are available in Haskell by default. For example, <code>filter</code> can be used to filter a list:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">filter even oneToFive</span></span></code></pre></figure>
<p>This will filter the even numbers in <code>oneToFive</code> and yield <code>[2,4]</code>. <code>even</code> is a simple function that takes an integer, and yields <code>True</code> if it’s even, and <code>False</code> if it isn’t. The <code>filter</code> function uses the function you pass it to test the elements of the list, and keeps the elements that pass the test.</p>
<p>Another popular function is <code>foldl</code> (short for “fold left,”) which “folds” a list as if folding a long piece of cardboard starting from the left and reducing it to a small piece. For example, we can use <code>foldl</code> to find the sum of all the elements of a list of integers:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">foldl (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> oneToFive</span></span></code></pre></figure>
<p>yields 15. <code>foldl</code> takes three arguments: the function used to calculate the result of every fold, the initial value to start folding with, and the list to fold. This is a bit abstract. If you know about <code>for</code> loops, you can think of folds as loop iterations, where in each iteration, you change the value of some accumulator. In the case of folding a list of integers to find their sum, the accumulator would be the sum, which starts at zero, and then increases with every number you pass in the list to finally be returned as the sum of all the numbers in the list.</p>
<p>Notice there’s something peculiar about the function we passed to <code>foldl</code>. As the function used to calculate the accumulator in each fold, we used <code>(+)</code>. This is possible because operators in Haskell are really just functions of two parameters. To multiply two integers, you pass them as arguments to the <code>(*)</code> function:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 4</span></span></code></pre></figure>
<p>both yield <code>8</code>.</p>
<p>Higher-order functions aren’t limited to lists. They can be used in all sorts of situations (e.g. <a href="https://en.wikipedia.org/wiki/Asynchrony_%28computer_programming%29" class="external">asynchronous programming<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>,) and they are a good tool for abstraction. We can generalize a formula by making some part of it unknown, and allowing it to be passed as an argument.</p>
<hr/>
<p>We’ve gone through many concepts so far. We’ve built a pretty good intuition about functions, and we’ve seen how powerful they are. We’ve also discussed types briefly, but now I’d like you to run these lines in the REPL:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">f</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; f x y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">*</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t f  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t (f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t (</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t length  </span></span>
<span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">t map</span></span></code></pre></figure>
<p>Take a quick look at the result of each of these. <code>:t</code> is a command you can use in the REPL to get the type of an expression. But what’s with these types? There are lots of <code>a</code>’s and fat arrows (<code>=></code>.) What do they mean? And the question about multiple arrows in the types of functions of multiple parameters remains unanswered! What have we been doing all this time!</p>
<h3 id="currying">Currying<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#currying" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>The result of <code>:t f</code> is <code>Int -> Int -> Int</code>, which is strange. The result of <code>:t (f 2)</code> is <code>Int -> Int</code>, which is even stranger. Doesn’t <code>f</code> take two arguments? Well, that’s the key: <code>f</code> takes two arguments, but <code>(f 2)</code> is another function that takes only one:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span></span></code></pre></figure>
<p>both yield <code>7</code>. You can even assign a name to <code>(f 2)</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">g </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (f </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></figure>
<p>Now <code>g</code> is a function just like <code>(f 2)</code>. It takes one integer argument, and yields an integer, so <code>g 3</code> will yield <code>7</code>. Since we’re applying <code>f</code> to only one argument, the value we provide will be used in place of the first parameter (<code>x</code>.) The resulting function takes the one remaining argument (<code>y</code>,) and finally yields an integer.</p>
<p>Currying (named after <a href="https://en.wikipedia.org/wiki/Haskell_Curry" class="external">Haskell Curry<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a>) is making a function yield another function when it’s not applied to enough arguments. If a curried function takes 5 arguments, applying it to 3 arguments will yield a function that takes 2 arguments. In Haskell, all functions are curried, which allows us to write more concise code. For example, instead of writing a function that sums the elements of a list as:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sum list </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foldl (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> list</span></span></code></pre></figure>
<p>we can just write:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> foldl (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span></span></code></pre></figure>
<p>Since <code>foldl</code> takes 3 arguments, and we’re applying it to 2 arguments, it will yield a function that takes one argument (the last parameter, a list,) and finally yields the sum.</p>
<p>Another example would be to use curried functions as arguments to higher-order functions. Remember <code>transform</code>? There’s actually a function just like it already defined called <code>map</code> that transforms every element of a list using some function you pass:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map increment oneToFive</span></span></code></pre></figure>
<p>will yield <code>[2,3,4,5,6]</code>. The addition operator is a function, though, and all functions are curried. So we can apply <code>(+)</code> to one argument, and get a function that takes one argument. So <code>increment</code> can be rewritten as:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">increment </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></figure>
<p>which is cool. But now we don’t really need <code>increment</code> since we have a clear simple way to get a function that increments a number. So a function <code>incrementAll</code> that increments all the elements in a list can be written as:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">incrementAll </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> map (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></figure>
<p>This works because <code>map</code> has two parameters (a function and a list,) and we’re only applying it to one argument. This is just beautiful.</p>
<hr/>
<p>Alright, we’ve discovered the secret of functions of multiple parameters. Now, let’s answer the question about all the <em>a</em>’s and <em>b</em>’s in types like <code>:t map:</code></p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> b) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [a] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [b]</span></span></code></pre></figure>
<h3 id="parametric-polymorphism">Parametric Polymorphism<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#parametric-polymorphism" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>What a tongue twister.</p>
<p>In previous sections, we looked at cases where you can generalize a definition by making some part of it unknown. Types are no different; if you take a look at the list type <code>[]</code> you might notice that it’s missing something: the type of elements within it. In order to create a list, you must make it a <em>list of something</em>, so you can think of the list type as a function on the type level that has a type parameter. So to construct a list type that has elements in it, you must pass some type to <code>[]</code>. The type <code>[Int]</code> is <code>Int</code> passed to <code>[]</code> as an argument. Because <code>[]</code> itself isn’t a complete type and it has a type parameter, it is called a <em>type constructor</em>.</p>
<p>Because a list can come in many forms (e.g. <code>[Int]</code>, <code>[Float]</code>, and <code>[String]</code>,) we say it’s <em>polymorphic</em>. Since the type argument is the part that varies among lists, we say it’s <em>parametrically polymorphic</em>.</p>
<p>The same idea applies to functions; in <code>:t map</code>, the type of the list doesn’t matter, because the operations we perform on the list require no knowledge of the type. That is why you see <code>[a]</code> and <code>[b]</code> in <code>:t map</code>. Both <code>a</code> and <code>b</code> can vary between different applications of <code>map</code>, which is why they’re called <em>type variables</em>, and <code>map</code> is called a <em>polymorphic function</em>. For example:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map  (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) oneToFive</span></span></code></pre></figure>
<p>Here, <code>a</code> is <code>Int</code>, and <code>b</code> is <code>Int</code>. So <code>map</code> has the type:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></figure>
<p>This also shows that <code>a</code> and <code>b</code> are not necessarily different types. Here’s another example:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">names </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;John&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jane&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;Jackson&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span data-line> </span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">map  length names</span></span></code></pre></figure>
<p>Here <code>a</code> is <code>String</code>, and <code>b</code> is <code>Int</code>. So the type of <code>map</code> is:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">String</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">Int</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></figure>
<p>This polymorphism becomes really useful when you want a function or a type to work with multiple types. If you were defining a list data structure, you shouldn’t care about the type it’ll be used with, because you would want it to be usable with any type. It’s also great that the Haskell compiler can figure out types on its own, so you don’t need to think about it too much. Simply define a function, and look at the type that the compiler has given to it, it’s usually the most generic type possible.</p>
<h3 id="type-classes">Type Classes<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#type-classes" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>Check out the type of <code>(+)</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">(+)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a</span></span></code></pre></figure>
<p>Ok, we understand from <code>a -> a -> a</code> that it’s a function that takes two <code>a</code>’s and yields an <code>a</code>. But what’s with the <code>Num a =></code> at the beginning?</p>
<p>Imagine you’re defining the <code>(+)</code> function. Would you want it to be usable with any type? I think not. You would want <code>(+)</code> to be usable with types that have properties of numbers (or I hope so, at least.) That’s what the <code>Num a</code> is for. It limits <code>a</code> to types that are number-like. But what is <code>Num</code>?</p>
<p>In order for something to be number-like, it has to support some operations like addition (<code>+</code>,) multiplication (<code>*</code>,) and a few others. If a type can be operated on using these functions, we consider it number-like.</p>
<p>In Haskell, you can define a <em>type class</em> containing the specification of functions that a type needs to support in order to be considered a member of some <em>class</em> of types.</p>
<p>The definition of the <a href="https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Num.html#Num" class="external"><code>Num</code><svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> type class looks like this:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  Num</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    (+), (-), (*)</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    negate</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    abs</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    signum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span></span>
<span data-line><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    fromInteger</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ::</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Integer</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -></span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> y </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> negate y  </span></span>
<span data-line><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    negate x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> x</span></span></code></pre></figure>
<p>Some of the functions every <code>Num</code> has to support aren’t concretely defined inside the type class. Functions like <code>(*)</code> and <code>abs</code> are left up to the author of <code>a</code> to define, so only their types are specified. Other functions like <code>(-)</code> have a default concrete definition, given by <code>x — y = x + negate y</code>, so the author of <code>a</code> needs only to define <code>negate</code> for <code>(-)</code> to become available.</p>
<p>Let’s define our own type class called <code>FillStatus</code>. Any member type of <code>FillStatus</code> must support a function <code>isEmpty</code> that tells us whether the argument is empty or not:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FillStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isEmpty </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">::</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> a </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-></span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> Bool</span></span></code></pre></figure>
<p>So <code>isEmpty</code> takes an <code>a</code> and returns a <code>Bool</code> (<code>True</code> or <code>False</code>.) Now let’s make lists satisfy the requirements of <code>FillStatus</code> by defining an <em>instance</em> of <code>FillStatus</code> for <code>[a]</code>:</p>
<figure data-rehype-pretty-code-figure><pre tabindex="0" data-language="haskell" data-theme="github-light github-dark"><code data-language="haskell" data-theme="github-light github-dark" style="display:grid;"><span data-line><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">instance</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> FillStatus</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [a] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">where</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> isEmpty </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">[]</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> True</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; isEmpty _ </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> False</span></span></code></pre></figure>
<p>The definition of <code>isEmpty</code> for lists is pretty straightforward: a list is empty if it’s the empty list (<code>[]</code>) and it’s not otherwise (that’s what the underscore means.) Awesome! Now <code>isEmpty []</code> yields <code>True</code>, and <code>isEmpty [1,2,3]</code> yields <code>False</code>!</p>
<p>We can provide an instance of <code>FillStatus</code> for any type we want (as long as it makes sense.) Type classes are similar to interfaces in other programming languages like Java, but there’s a key difference between the two: you don’t need to specify which type classes a type belongs to while defining it. <code>Int</code> is already defined, and we can still create an instance of <code>FillStatus Int</code> without modifying the definition of <code>Int</code>.</p>
<h3 id="conclusion">Conclusion<a role="anchor" aria-hidden="true" tabindex="-1" data-no-popover="true" href="#conclusion" class="internal"><svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg></a></h3>
<p>We’ve looked at many functional programming concepts in this article. However, this is by no means a comprehensive explanation of FP or Hakell. It is an introduction and a quick overview. After understanding the contents of this article, you should be able to read a lot of Haskell code, and write code in a functional way. I haven’t mentioned things like state, Haskell’s relationship with category theory , or even fundamental things like <a href="https://wiki.haskell.org/Anonymous_function" class="external">anonymous functions<svg class="external-icon" viewBox="0 0 512 512"><path d="M320 0H288V64h32 82.7L201.4 265.4 178.7 288 224 333.3l22.6-22.6L448 109.3V192v32h64V192 32 0H480 320zM32 32H0V64 480v32H32 456h32V480 352 320H424v32 96H64V96h96 32V32H160 32z"></path></svg></a> because this article is long as it is. But I’ll be writing more in the future.</p></article></div><div class="right sidebar"><div class="toc desktop-only"><button type="button" id="toc" class><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#functions" data-for="functions">Functions!</a></li><li class="depth-0"><a href="#function-types" data-for="function-types">Function Types</a></li><li class="depth-0"><a href="#lists" data-for="lists">Lists</a></li><li class="depth-0"><a href="#recursion" data-for="recursion">Recursion</a></li><li class="depth-0"><a href="#higher-order-functions" data-for="higher-order-functions">Higher-Order Functions</a></li><li class="depth-0"><a href="#currying" data-for="currying">Currying</a></li><li class="depth-0"><a href="#parametric-polymorphism" data-for="parametric-polymorphism">Parametric Polymorphism</a></li><li class="depth-0"><a href="#type-classes" data-for="type-classes">Type Classes</a></li><li class="depth-0"><a href="#conclusion" data-for="conclusion">Conclusion</a></li></ul></div></div></div></div><footer class><hr/><ul><li><a href="https://x.com/_tabaza">X</a></li><li><a href="https://www.linkedin.com/in/muhammad-tabaza/">LinkedIn</a></li><li><a href="https://github.com/m-tabaza/">GitHub</a></li><li><a href="https://tabaza.dev/index.xml">RSS</a></li></ul></footer></div></body><script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/copy-tex.min.js" type="application/javascript"></script><script type="application/javascript">function c(){let t=this.parentElement;t.classList.toggle("is-collapsed");let l=t.classList.contains("is-collapsed")?this.scrollHeight:t.scrollHeight;t.style.maxHeight=l+"px";let o=t,e=t.parentElement;for(;e;){if(!e.classList.contains("callout"))return;let n=e.classList.contains("is-collapsed")?e.scrollHeight:e.scrollHeight+o.scrollHeight;e.style.maxHeight=n+"px",o=e,e=e.parentElement}}function i(){let t=document.getElementsByClassName("callout is-collapsible");for(let s of t){let l=s.firstElementChild;if(l){l.addEventListener("click",c),window.addCleanup(()=>l.removeEventListener("click",c));let e=s.classList.contains("is-collapsed")?l.scrollHeight:s.scrollHeight;s.style.maxHeight=e+"px"}}}document.addEventListener("nav",i);window.addEventListener("resize",i);
</script><script type="module">
          let mermaidImport = undefined
          document.addEventListener('nav', async () => {
            if (document.querySelector("code.mermaid")) {
              mermaidImport ||= await import('https://cdnjs.cloudflare.com/ajax/libs/mermaid/10.7.0/mermaid.esm.min.mjs')
              const mermaid = mermaidImport.default
              const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
              mermaid.initialize({
                startOnLoad: false,
                securityLevel: 'loose',
                theme: darkMode ? 'dark' : 'default'
              })

              await mermaid.run({
                querySelector: '.mermaid'
              })
            }
          });
          </script><script src="../postscript.js" type="module"></script></html>